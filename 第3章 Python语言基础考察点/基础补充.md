## 语言类型
- 编译型和解释型
- 动态语言和静态语言
- 强类型定义语言和弱类型定义语言

- 动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，**该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。**Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。
- 强类型定义语言：强制数据类型定义的语言。也就是说，**一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。**举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。

## 编码
- [python编码问题大终结](https://www.cnblogs.com/vipchenwei/p/6993788.html)
- [Python（字符编码）](https://www.cnblogs.com/zihe/p/6993891.html)

1. 使用编辑器编写py文件保存只是将内存中unicode编码的内容使用系统或者编辑器的编码方式保存到硬盘中.
2. python解释器执行py文件首先是作为一个编辑器将py文件从硬盘中读取到内存, 然后再进行解释.
3. python2默认ascii, python3默认utf-8, 在python2文件中有#coding:utf-8, 那么文件会以utf-8方式解码成unicode放到内存中.最终到内存中都是unicode. 但是程序还没有开始解释.
4. 读取已经加载到内存的代码（unicode编码的二进制），然后执行，**但是程序在执行过程中，会申请内存（与程序代码所存在的内存是俩个空间）**，可以存放任意编码格式的数据，比如x="egon",会被python解释器识别为字符串，会申请内存空间来存放"hello"，然后让x指向该内存地址，此时新申请的该内存地址保存也是unicode编码的egon,如果代码换成x="egon".encode('utf-8'),那么新申请的内存空间里存放的就是utf-8编码的字符串egon了

![](http://qiniu.rearib.top/20191913/1303-Q.png)

### python3中两种字符串类型str和bytes
str是unicode

bytes是bytes

```
#coding:utf-8
s='林' #当程序执行时，无需加u，'林'也会被以unicode形式保存新的内存空间中,

#s可以直接encode成任意编码格式
s1=s.encode('utf-8')
s2=s.encode('gbk')

print(s) #林
print(s1) #b'\xe6\x9e\x97' 在python3中，是什么就打印什么
print(s2) #b'\xc1\xd6' 同上

print(type(s)) #<class 'str'>
print(type(s1)) #<class 'bytes'>
print(type(s2)) #<class 'bytes'>
```

### python2中两种字符串类型str和unicode
在python2中，**str就是编码后的结果bytes，str=bytes,所以在python2中，unicode字符编码的结果是str/bytes**

当python解释器执行到产生字符串的代码时（例如s='林'），会申请新的内存地址，然后将'林'encode成文件开头指定的编码格式

```
#coding:utf-8
s='林' #在执行时,'林'会被以conding:utf-8的形式保存到新的内存空间中

print repr(s) #'\xe6\x9e\x97' 三个Bytes,证明确实是utf-8
print type(s) #<type 'str'>

s.decode('utf-8')
# s.encode('utf-8') #报错，s为编码后的结果bytes，所以只能decode
```

当python解释器执行到产生字符串的代码时（例如s=u'林'），会申请新的内存地址，然后将'林'以unicode的格式存放到新的内存空间中，所以s只能encode，不能decode

```
s=u'林' 
print repr(s) #u'\u6797'
print type(s) #<type 'unicode'>


# s.decode('utf-8') #报错，s为unicode，所以只能encode
s.encode('utf-8') 
```

### 打印到终端
print(x) #这一步是将x指向的那块新的内存空间（非代码所在的内存空间）中的内存，打印到终端，而终端仍然是运行于内存中的，所以这打印可以理解为从内存打印到内存，即内存->内存，unicode->unicode

- 对于unicode格式的数据来说，即python3中的字符串与python2中的u'字符串'，都是unicode，所以无论如何打印都不会乱码

- 在python2中存在另外一种非unicode的字符串，此时，print x，会按照终端的编码执行x.decode('终端编码')，变成unicode后，再打印，此时终端编码若与文件开头指定的编码不一致，乱码就产生了(在windows终端, 终端编码为gbk, x指向的内容是utf-8编码的, 就会出现乱码)

### 常见编码错误的原因有：
- Python解释器的默认编码
- Python源文件文件编码
- Terminal使用的编码
- 操作系统的语言设置

## 关键字
- assert 检查条件, 不符合就终止程序
- exec 动态地执行复杂的Python代码
- str 将对象X转换为字符串(适于人阅读的形式)
- repr 将对象X转换为表达式字符串(供解释器读取的形式)
- eval 计算在字符串中的有效Python表达式并返回一个对象
- chr 整数转换为一个字符
- ord 字符转换为一个整数
- hex 整数转换为十六进制字符串
- oct 整数转换为八进制字符串

- input获取得到的是str

## 深浅拷贝
### 变量-引用-对象
在Python中一切都是对象, Python中变量是指对象的引用，Python是动态类型，程序运行时候，会根据对象的类型来确认变量到底是什么类型。

运行a=3后，变量a变成了对象3的一个引用。在内部，变量事实上是到对象内存空间的一个指针

![](http://qiniu.rearib.top/20191913/1434-a.png)

Python的变量不过是对象的引用，或指向对象的指针，因此在程序中可以经常改变变量引用

```
>>> x = 42      #变量绑定到整型对象
>>> x = 'Hello' #现在又成了字符串
>>> x = [1,2,3] #现在又成了列表
```
![](http://qiniu.rearib.top/20191913/1436-U.png)

### 可变与不可变对象
- 在Python中不可变对象指：一旦创建就不可修改的对象，包括字符串，元祖，数字(a=b, a的值发生改变，b不会跟着改变)
- 在Python中可变对象是指：可以修改的对象，包括：列表、字典(a=b, a的值发生改变，b也跟着改变)

### 深拷贝与浅拷贝(针对可变对象)
- 浅拷贝：只拷贝顶级的对象，或者说：父级对象
- 深拷贝：拷贝所有对象，顶级对象及其嵌套对象。或者说：父级对象及其子对象
- 深浅拷贝都是对源对象的复制，占用不同的内存空间
- 如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象
- 如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝
- 序列对象的切片其实是浅拷贝，即只拷贝顶级的对象
- **要想完全无关, 需要使用深拷贝**

## 数据类型
### 字符串
[字符串内置函数](https://www.cnblogs.com/derek1184405959/p/8041926.html)

### 列表
#### 列表排序reverse、sort、sorted
- reverse() 反转, 不会排序
- sort() 排序, 排序后的新列表会覆盖原列表(默认正向排序)
- sorted() 排序, 可以保留原列表, 又能得到已经排序好的列表(默认正向排序)
- a[::-1] 反转, 不会排序

```
>>> x = [1,5,2,3,4]
>>> x.reverse()
>>> x
[4, 3, 2, 5, 1]

>>> a = [5,7,6,3,4,1,2]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5, 6, 7]

>>> a = [5,7,6,3,4,1,2]
>>> b = sorted(a)
>>> a
[5, 7, 6, 3, 4, 1, 2]
>>> b
[1, 2, 3, 4, 5, 6, 7]
```

#### enumerate
同时需要用到index和value值的时候可以用到enumerate，参数为可遍历的变量，如字符串，列表等，返回enumerate类。

`(0, seq[0]), (1, seq[1]), (2, seq[2]), ...`

### 元组
- index, count

### 字典
- items(), keys(), values()

### 集合
- set()
- add() 添加一个
- update() 添加多个
- remove() 移除
- 交集, 并集, 差集

可以使用大括号{}或者set()函数创建集合, 注意: 创建一个空集合必须用set()而不是{}, 因为{}是用来创建一个空字典。
```
parame = {value01,value02,...} # 重复的元素被自动去掉
or
set(value)  
```

### 总结
- 数字
- 字符串
- 列表 []
- 元组 ()
- 字典 {}
- 集合 set()

## 文件

### 常用方法
- read() 读取文件所有内容
- readline() 只读取一行内容
- readlines() 把文章内容以换行符分割，并生成list格式（数据量大的时候不建议用）
- tell() 获取文件读取指针的位置
- seek() 移动文件读写指针到指定的位置
- flush() 手动刷新缓冲区，将缓冲区中的数据立刻写入文件，同时清空缓冲区
- with语句
- 二进制操作

**默认光标在起始的位置，read()读取完后，光标停留到文件末尾**

|访问模式|说明|指针位置|文件存在|文件不存在|
|-|-|-|-|-|
|r|只读|开头|从头读取内容|报错|
|w|只写|开头|覆盖写入新内容|创建新文件写入新内容|
|a|追加|结尾|结尾追加新内容|创建新文件写入新内容|
|rb|二进制格式只读|开头|从头读取内容|报错|
|wb|二进制格式只写|开头|覆盖写入新内容|创建新文件写入新内容|
|ab|二进制格式追加|结尾|结尾追加新内容|创建新文件写入新内容|
|r+|读写方式打开|开头|从头读或覆盖写|报错|
|w+|读写方式打开|开头|清空之前的内容|创建新文件写入新内容|
|a+|读写方式打开|结尾|结尾追加新内容, 读取返回空|创建新文件写入新内容|
|rb+|二进制格式读写|开头|从头读或覆盖写|报错|
|wb+|二进制格式读写|开头|清空之前的内容|创建新文件写入新内容|
|ab+|二进制格式读写|结尾|结尾追加新内容, 读取返回空|创建新文件写入新内容|

```
if os.path.exists(File):
    outFile=open(File, 'r+') # 如果文件存在追加
else:
    outFile=open(File, 'w+') # 如果不存在创建
```

## 函数
### 参数
```
def info(name, age, country = 'CN', *args, **kwargs): # 必填参数、默认值参数、可变参数、关键字参数
    name = 'rearib'  # 局部变量
    print(name)
func('rearib', 12)   # 位置测试
func(age=22, name='rearib')   # 关键字参数

```
- name是形式参数
- 'rearib'是传入的实参
- country是默认参数, 传入了默认值
- 位置参数传参，需要按顺序
- 关键字参数传参，可以不按顺序
- 局部变量作用域在函数内部，不影响外部
- *args会把多传入的参数变成一个元祖形式
- **kwargs会把多传入的参数变成一个dict形式

### 递归函数
一个函数在内部调用自身, 就叫递归函数
- 必须有一个明确的结束条件；
- 每次进入更深一层递归时，问题规模相比上次递归都应有所减少；
- 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出

### 高阶函数
满足下列条件之一就可称函数为高阶函数
- 某一函数当做参数传入另一个函数中
- 函数的返回值包含一个或多个函数

#### map()函数
map()是Python内置的高阶函数，它接收一个函数f和一个list，并通过把函数f依次作用在list的每个元素上，得到一个新的list并返回
```
def func(x):
    return x * x
a= map(func,range(1,10))
print(list(a))

[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

#### filter()函数
filter()函数接收一个函数f和一个list，这个函数f的作用是对每个元素进行判断，返回True或False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list
```
def is_odd(x):
    return x % 2 == 1
a = filter(is_odd,[1,2,3,4,5,6,7,8])
print(list(a))

[1, 3, 5, 7]
```

### 匿名函数lambda
lambda函数是一种快速定义单行的最小函数

lambda 传入的参数:参数处理
```
def fun(x,y):
    return x + y

a = lambda x,y:x + y

fun(1,2)
a(1,2)
```

### 函数嵌套和作用域
在一个函数中定义了另外一个函数, 参数依据就近原则, 从里往外找














### 闭包

### Python内置函数


## 迭代器
### 生成器
通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，**在Python中，这种一边循环一边计算的机制，称为生成器：generator**


### 容器

### 迭代器(iterator)
它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__方法的对象都是迭代器
- __iter__返回迭代器自身
- __next__返回容器中的下一个值
- 如果容器中没有更多元素了，则抛出StopIteration异常




















