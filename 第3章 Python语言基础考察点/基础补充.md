<!-- TOC -->autoauto- [语言类型](#语言类型)auto- [编码](#编码)auto    - [python3中两种字符串类型str和bytes](#python3中两种字符串类型str和bytes)auto    - [python2中两种字符串类型str和unicode](#python2中两种字符串类型str和unicode)auto    - [打印到终端](#打印到终端)auto    - [常见编码错误的原因有：](#常见编码错误的原因有)auto- [关键字](#关键字)auto- [深浅拷贝](#深浅拷贝)auto    - [变量-引用-对象](#变量-引用-对象)auto    - [可变与不可变对象](#可变与不可变对象)auto    - [深拷贝与浅拷贝(针对可变对象)](#深拷贝与浅拷贝针对可变对象)auto- [数据类型](#数据类型)auto    - [字符串](#字符串)auto    - [列表](#列表)auto    - [元组](#元组)auto    - [字典](#字典)auto    - [集合](#集合)autoauto<!-- /TOC -->

## 语言类型
- 编译型和解释型
- 动态语言和静态语言
- 强类型定义语言和弱类型定义语言

- 动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，**该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。**Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。
- 强类型定义语言：强制数据类型定义的语言。也就是说，**一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。**举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。

## 编码
- [python编码问题大终结](https://www.cnblogs.com/vipchenwei/p/6993788.html)
- [Python（字符编码）](https://www.cnblogs.com/zihe/p/6993891.html)

1. 使用编辑器编写py文件保存只是将内存中unicode编码的内容使用系统或者编辑器的编码方式保存到硬盘中.
2. python解释器执行py文件首先是作为一个编辑器将py文件从硬盘中读取到内存, 然后再进行解释.
3. python2默认ascii, python3默认utf-8, 在python2文件中有#coding:utf-8, 那么文件会以utf-8方式解码成unicode放到内存中.最终到内存中都是unicode. 但是程序还没有开始解释.
4. 读取已经加载到内存的代码（unicode编码的二进制），然后执行，**但是程序在执行过程中，会申请内存（与程序代码所存在的内存是俩个空间）**，可以存放任意编码格式的数据，比如x="egon",会被python解释器识别为字符串，会申请内存空间来存放"hello"，然后让x指向该内存地址，此时新申请的该内存地址保存也是unicode编码的egon,如果代码换成x="egon".encode('utf-8'),那么新申请的内存空间里存放的就是utf-8编码的字符串egon了

![](http://qiniu.rearib.top/20191913/1303-Q.png)

### python3中两种字符串类型str和bytes
str是unicode

bytes是bytes

```
#coding:utf-8
s='林' #当程序执行时，无需加u，'林'也会被以unicode形式保存新的内存空间中,

#s可以直接encode成任意编码格式
s1=s.encode('utf-8')
s2=s.encode('gbk')

print(s) #林
print(s1) #b'\xe6\x9e\x97' 在python3中，是什么就打印什么
print(s2) #b'\xc1\xd6' 同上

print(type(s)) #<class 'str'>
print(type(s1)) #<class 'bytes'>
print(type(s2)) #<class 'bytes'>
```

### python2中两种字符串类型str和unicode
在python2中，**str就是编码后的结果bytes，str=bytes,所以在python2中，unicode字符编码的结果是str/bytes**

当python解释器执行到产生字符串的代码时（例如s='林'），会申请新的内存地址，然后将'林'encode成文件开头指定的编码格式

```
#coding:utf-8
s='林' #在执行时,'林'会被以conding:utf-8的形式保存到新的内存空间中

print repr(s) #'\xe6\x9e\x97' 三个Bytes,证明确实是utf-8
print type(s) #<type 'str'>

s.decode('utf-8')
# s.encode('utf-8') #报错，s为编码后的结果bytes，所以只能decode
```

当python解释器执行到产生字符串的代码时（例如s=u'林'），会申请新的内存地址，然后将'林'以unicode的格式存放到新的内存空间中，所以s只能encode，不能decode

```
s=u'林' 
print repr(s) #u'\u6797'
print type(s) #<type 'unicode'>


# s.decode('utf-8') #报错，s为unicode，所以只能encode
s.encode('utf-8') 
```

### 打印到终端
print(x) #这一步是将x指向的那块新的内存空间（非代码所在的内存空间）中的内存，打印到终端，而终端仍然是运行于内存中的，所以这打印可以理解为从内存打印到内存，即内存->内存，unicode->unicode

- 对于unicode格式的数据来说，即python3中的字符串与python2中的u'字符串'，都是unicode，所以无论如何打印都不会乱码

- 在python2中存在另外一种非unicode的字符串，此时，print x，会按照终端的编码执行x.decode('终端编码')，变成unicode后，再打印，此时终端编码若与文件开头指定的编码不一致，乱码就产生了(在windows终端, 终端编码为gbk, x指向的内容是utf-8编码的, 就会出现乱码)

### 常见编码错误的原因有：
- Python解释器的默认编码
- Python源文件文件编码
- Terminal使用的编码
- 操作系统的语言设置

## 关键字
- assert 检查条件, 不符合就终止程序
- exec 动态地执行复杂的Python代码
- str 将对象X转换为字符串(适于人阅读的形式)
- repr 将对象X转换为表达式字符串(供解释器读取的形式)
- eval 计算在字符串中的有效Python表达式并返回一个对象
- chr 整数转换为一个字符
- ord 字符转换为一个整数
- hex 整数转换为十六进制字符串
- oct 整数转换为八进制字符串

- input获取得到的是str

## 深浅拷贝
### 变量-引用-对象
在Python中一切都是对象, Python中变量是指对象的引用，Python是动态类型，程序运行时候，会根据对象的类型来确认变量到底是什么类型。

运行a=3后，变量a变成了对象3的一个引用。在内部，变量事实上是到对象内存空间的一个指针

![](http://qiniu.rearib.top/20191913/1434-a.png)

Python的变量不过是对象的引用，或指向对象的指针，因此在程序中可以经常改变变量引用

```
>>> x = 42      #变量绑定到整型对象
>>> x = 'Hello' #现在又成了字符串
>>> x = [1,2,3] #现在又成了列表
```
![](http://qiniu.rearib.top/20191913/1436-U.png)

### 可变与不可变对象
- 在Python中不可变对象指：一旦创建就不可修改的对象，包括字符串，元祖，数字(a=b, a的值发生改变，b不会跟着改变)
- 在Python中可变对象是指：可以修改的对象，包括：列表、字典(a=b, a的值发生改变，b也跟着改变)

### 深拷贝与浅拷贝(针对可变对象)
- 浅拷贝：只拷贝顶级的对象，或者说：父级对象
- 深拷贝：拷贝所有对象，顶级对象及其嵌套对象。或者说：父级对象及其子对象
- 深浅拷贝都是对源对象的复制，占用不同的内存空间
- 如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象
- 如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝
- 序列对象的切片其实是浅拷贝，即只拷贝顶级的对象
- **要想完全无关, 需要使用深拷贝**

## 数据类型
### 字符串


### 列表


### 元组


### 字典


### 集合






