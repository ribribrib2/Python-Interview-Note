## Mysq索引
- 索引的原理、类型、结构
- 创建索引的注意事项,使用原则
- 如何排査和消除慢查询

### 为什么需要索引?
- 索引是数据表中一个或者多个列进行排序的数据结构
- 索引能够大幅提升检索速度(回顾下你所知道的查找结构: 线性查找|二分查找|树形查找)
- 创建、更新索引本身也会耗费空间和时间

### 查找结构进化史
- 线性査找：一个个找、实现简单、太慢
- 二分査找：有序、简单、要求是有序的、插入特别慢 
- HASH：査询快、占用空间、不太适合存储大规模数据
- 二叉査找树：插入和查询很快(log(n))、无法存大规模数据、复杂度退化
- 平衡树：解决bst退化的问题、树是平衡的、节点非常多的时候、依然树很高
- 多路査找树：一个父亲多个孩子节点(度)、节点过多树高不会特别深
- 多路平衡查找树：B-Tree

### 数据结构可视化网站
[网站](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

## 什么是B-Tree?
**什么是B-Tree,为什么要使用B-Tree**
- 多路平衡查找树(每个节点最多m(m>=2)个孩子称为m阶或者度)
- 叶节点具有相同的深度
- 节点中的数据key从左到右是递增的
![](http://qiniu.rearib.top/20191909/1750-2.png)

## B+Tree 
**B+树是B-Tree的变形**
- Mysql实际使用的B+Tree作为索引的数据结构
- 只在叶子节点带有指向记录的指针(为什么?可以增加树的度)
- 叶子结点通过指针相连.为什么?实现范围查询
![](http://qiniu.rearib.top/20191909/1755-3.png)
- 为什么不是阶越大越好
![](http://qiniu.rearib.top/20191909/1755-v.png)

## Mysql索引的类型 
- 普通索引(CREATE INDEX)
- 唯一索引、索引列的值必须唯一(CREATE UNIQUE INDEX)
- 多列索引
- 主键索引(PRIMARY KEY),一个表只能有一个
- 全文索引(FULLTEXT INDEX), InnoDB不支持

### 什么时候创建索引?
**建表的时候需要根据查询需求来创建索引**
- 经常用作查询条件的字段(WHERE条件)
- 经常用作表连接的字段
- 经常出现在order by, group by之后的字段

### 创建索引有哪些需要注意的?
- 非空字段NOT NULL,Mysql很难对空值作查询优化
- 区分度高,离散度大,作为索引的字段值尽量不要有大量相同值
- 索引的长度不要太长(比较耗费时间)

### 索引什么时候失效?
**记忆口诀:模糊匹配、类型隐转、最左匹配**
- 以%开头的LIKE语句,模糊搜索
- 出现隐式类型转换(在 Python这种动态语言查询中需要注意)
- 没有满足最左前缀原则(想想为什么是最左匹配?

### 什么是聚集索引和非聚集索引?
- 聚集还是非聚集指的是B+Tree叶节点存的是指针还是数据记录
- MyISAM索引和数据分离,使用的是非聚集索引
- InnoDB数据文件就是索引文件,主键索引就是聚集索引

#### 非聚集索引
![](http://qiniu.rearib.top/20191909/1810-c.png)

#### 聚集索引
![](http://qiniu.rearib.top/20191909/1811-C.png)

#### 聚集索引与辅助索引
辅助索引先找到主键以后再根据主键找到数据
![](http://qiniu.rearib.top/20191909/1814-6.png)

###如何排查慢查询
**慢查询通常是缺少索引,索引不合理或者业务代码实现导致**
- slow_query_log_fie开启并且查询慢查询日志
- 通过explain排查索引问题
- 调整数据修改索引;业务代码层限制不合理访问


