## 考点聚焦 Mysql基础考点
- 事务的原理、特性、事务并发控制
- 常用的字段、含义和区别
- 常用数据库引擎之间区别

### 什么是事务? Transaction
- 事务是数据库并发控制的基本单位
- 事务可以看作是一系列SQL语句的集合
- 事务必须要么全部执行成功,要么全部执行失败(回滚)

#### Transaction示例
![](http://qiniu.rearib.top/20191909/1615-b.png)

#### ACID是事务的四个基本特性
- 原子性(Atomicity):一个事务中所有操作全部完成或失败
- 一致性(Consistency):事务开始和结朿之后数据完整性没有被破坏
- 隔离性(Isolation):允许多个事务同时对数据库修改和读写
- 持久性(Durability):事务结束之后,修改是永久的不会丢失


### 事务的并发控制可能产生哪些问题
**如果不对事务进行并发控制,可能会产生四种异常情况**
- 幻读(phantom read):一个事务第二次查出现第一次没有的结果
- 非重复读(nonrepeatable read):一个事务重复读两次得到不同结果
- 脏读(dirty read):一个事务读取到另一个事务没有提交的修改
- 丢失修改(lost update):并发写入造成其中一些修改丢失

### 四种事务隔离级别
**为了解决并发控制异常,定义了4种事务隔离级别**
- 读未提交(read uncommitted):别的事务可以读取到未提交改变
- 读已提交(read committed):只能读取已经提交的数据
- 可重复读(repeatable read):同一个事务先后查询结果一样(Mysql InnoDB默认实现可重复读级别)
- 串行化(Serializable):事务完全串行化的执行,隔离级别最高,执行效率最低

### 如何解决高并发场景下的插入重复
**高并发场景下,写入数据库会有数据重复问题**
- 使用数据库的唯一索引
- 使用队列异步写入
- 使用redis等实现分布式锁

### 乐观锁和悲观锁
- 悲观锁是先获取锁再进行操作.一锁二查三更新(select for update)
- 乐观锁先修改更新的时候发现数据已经变了就回滚(check and set)
- 使需要根据响应速度、冲突频率、重试代价来判断使用哪一种
- 乐观锁一般通过版本号或者时间戳实现

## mysql常用数据类型
- 字符串(文本)
- 数值(整数、float、double)
- 日期和时间

**float和double的精度不一样**

## InnoDB VS MyISAM
### 两种引擎常见的区别
- MyISAM不支持事务, InnoDB支持事务
- MyISAM不支持外键, InnoDB支持外键
- MyISAM只支持表锁, InnODB支持行锁和表锁

- InnoDB是不支持全文搜索的。同时，启动也比较的慢，它是不会保存表的行数的。当进行Select count(*) from table指令的时候，需要进行扫描全表。所以**当需要使用数据库的事务时，该引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。**
- MyIASM是MySql的默认引擎，不提供事务的支持，也不支持行级锁和外键。因此当执行Insert插入和Update更新语句时，即**执行写操作的时候需要锁定这个表。所以会导致效率会降低。**不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，**如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先。**

### 两种引擎所使用的索引的数据结构是什么？
- B+树

## 数据存储知识点
- 文件系统及数据库系统的设计者利用了磁盘预读原理, 将一个节点的大小设为等于一个页, 这样每个节点只需要一次I/O就可以完全载入

### B树和B+树















